package safayat.orm.dao;

import safayat.orm.annotation.ManyToOne;
import safayat.orm.annotation.OneToMany;
import safayat.orm.annotation.Table;
import safayat.orm.config.ConfigManager;
import safayat.orm.jdbcUtility.PrimaryKeyInfo;
import safayat.orm.jdbcUtility.ResultSetUtility;
import safayat.orm.model.Option;
import safayat.orm.reflect.Util;
import safayat.orm.reflect.ReflectUtility;

import java.lang.annotation.Annotation;
import java.sql.*;
import java.util.*;
import java.util.stream.Stream;

/**
 * Created by safayat on 10/20/18.
 */
public class GeneralRepository {


    private Connection getConnection() throws SQLException {
        return ConfigManager.getInstance().getConnection();
    }

    private ResultSetUtility executeQuery(String sql) {
        Connection dbConnection = null;
        PreparedStatement statement = null;
        try {

            dbConnection = getConnection();
            statement = dbConnection.prepareStatement(sql);
            ResultSet rs = statement.executeQuery();
            try {
                return new ResultSetUtility(rs);
            } catch (Exception e) {
                e.printStackTrace();
            }

        } catch (SQLException e) {
            e.printStackTrace();
            closeResourcesSafely(dbConnection, statement);
        }
        return null;

    }


    public Object execute(String sql) throws SQLException {
        return execute(sql, getConnection());
    }

    public boolean execute(String sql, Connection dbConnection) throws SQLException{
        Statement statement = null;

        try {
                statement = dbConnection.createStatement();
                return statement.execute(sql);

        } finally {
            closeResourcesSafely(null, statement);
        }


    }
    private Object executeInsert(Object singleRow, Connection dbConnection) throws Exception{
        Statement statement = null;
        Object autoGeneratedPrimaryKey = null;

        try {
                statement = dbConnection.createStatement();
                statement.executeUpdate(ReflectUtility.createInsertSqlString(singleRow), Statement.RETURN_GENERATED_KEYS);
                PrimaryKeyInfo primaryKeyInfo = ConfigManager.getInstance().getPrimaryKeyInfo(singleRow.getClass());
                Class type = primaryKeyInfo.getKeyType(primaryKeyInfo.getSinglePrimaryKey());
                if(primaryKeyInfo.isAutoIncrement()){
                    ResultSet rs = statement.getGeneratedKeys();
                    while (rs.next()){
                        autoGeneratedPrimaryKey = ReflectUtility.getColumnFromResultByGivenType(type, rs, 1);
                        updateObjectWithAutoGeneratedKey(singleRow, autoGeneratedPrimaryKey);
                        break;
                    }
                    rs.close();

                }

        } finally {
            closeResourcesSafely(null, statement);
        }

        return autoGeneratedPrimaryKey;

    }


    private int[] executeBatch(String[] sqls) throws SQLException {
        return executeBatch(sqls, getConnection());
    }

    private int[] executeBatch(String[] sqls, Connection dbConnection) throws SQLException{
        Statement statement = null;
        try {
                statement = dbConnection.createStatement();
                for(String sql : sqls){
                    statement.addBatch(sql);
                }
                return statement.executeBatch();

        } catch (SQLException e) {
            throw new SQLException(e.getMessage());
        }finally {
            closeResourcesSafely(null, statement);
        }
    }

    public <T> T get(Class<T> tClass, Object id) {
        Connection dbConnection = null;
        PreparedStatement statement = null;
        try {

            dbConnection = getConnection();
            Table table = tClass.getAnnotation(Table.class);
            List<String> primaryKeys = getPrimaryKeys(ConfigManager.getInstance().getTableName(tClass), dbConnection);

            if( primaryKeys.isEmpty()) throw new SQLException("Primary key not found");
            if( primaryKeys.size() > 1) throw new SQLException("Not applicable for composed primary keys");

            StringBuilder sqlBuilder = new StringBuilder("select * from ")
                    .append(ConfigManager.getInstance().getTableName(tClass))
                    .append(" where ").append(primaryKeys.get(0))
                    .append(" = ").append(Util.toMysqlString(id));

            statement = dbConnection.prepareStatement(sqlBuilder.toString());
            ResultSet rs = statement.executeQuery();
            if(rs!=null && rs.next()){
                ResultSetUtility resultSetUtility = new ResultSetUtility(rs);
                return resultSetUtility.mapRow(tClass);
            }

        } catch (Exception e) {
            e.printStackTrace();
            closeResourcesSafely(dbConnection, statement);
        }
        return null;

    }

    public <T> T mapSingleObject(Class<T> tClass, ResultSet resultSet) throws Exception{
       return new ResultSetUtility(resultSet).mapRow(tClass);
    }


    private boolean isInsertOperation(Object t)throws Exception{

        String tableName = ConfigManager.getInstance().getTableName(t.getClass());
        PrimaryKeyInfo primaryKeyInfo = ConfigManager.getInstance().getPrimaryKeyInfo(tableName);
        return primaryKeyInfo == null || (ReflectUtility.isPrimaryKeyEmpty(t, primaryKeyInfo.getSinglePrimaryKey()) && primaryKeyInfo.isAutoIncrement());
    }
    private boolean isInvalidForInsertOrUpdate(Object t)throws Exception{

        String tableName = ConfigManager.getInstance().getTableName(t.getClass());
        PrimaryKeyInfo primaryKeyInfo = ConfigManager.getInstance().getPrimaryKeyInfo(tableName);
        return primaryKeyInfo != null &&
                !primaryKeyInfo.isAutoIncrement() &&
                ReflectUtility.isPrimaryKeyEmpty(t, primaryKeyInfo.getSinglePrimaryKey());
    }

    public <T> void insert(T t)throws Exception{
        insert(t, getConnection());
    }

    private  <T> Object insertOrUpdateSingleObject(T t, Connection connection)throws Exception{
        if(isInsertOperation(t)){
            return executeInsert(t, connection);
        }
        update(t ,connection);
        return null;
    }

    public   void insertOrUpdate(Object tree) throws Exception{
        insertOrUpdate(tree, getConnection());
    }

    public void insertOrUpdate(Object tree, Connection connection)throws Exception{
        Map<Object, Boolean> executedNodes = new HashMap<>();
        processRelationalInsertOrUpdate(tree, executedNodes, connection);
    }


    public <T> void insert(T t, Connection connection) throws Exception {
       Object key =  executeInsert(t, connection);
       updateObjectWithAutoGeneratedKey(t, key);
    }

    public <T> int[] insert(List<T> objects)throws Exception{
        return insert(objects, getConnection());
    }

    public <T> int[] insert(List<T> objects, Connection connection) throws Exception {
       List<String> sqls = new ArrayList<>();
        for(Object o : objects){
            sqls.add(ReflectUtility.createInsertSqlString(o));
        }
        return executeBatch(sqls.toArray(new String[0]), connection);
    }


    private void processRelationalInsertOrUpdate(Object t
            , Map<Object, Boolean> nodes
            , Connection connection) throws Exception {


        if(nodes.containsKey(t) || isInvalidForInsertOrUpdate(t)) return;

        Object generatedKey = insertOrUpdateSingleObject(t, connection);
        nodes.put(t, true);

        for(Annotation annotation : Util.getFieldAnnotations(t.getClass(), OneToMany.class)){
            OneToMany oneToMany = (OneToMany)annotation;
            if(!ReflectUtility.haveOneToManyRelationInfo(oneToMany)) continue;
            List childs = (List)ReflectUtility.parseFieldValueFromObject(t, oneToMany.name());
            if(childs != null){
                updateChildsWithAutoGeneratedKeys(childs, generatedKey, oneToMany.matchingColumnName());
                for(Object o : childs){
                    processRelationalInsertOrUpdate(o, nodes, connection);
                }
            }
        }

        for(Annotation annotation : Util.getFieldAnnotations(t.getClass(), ManyToOne.class)){
            ManyToOne manyToOne = (ManyToOne)annotation;
            if(!ReflectUtility.haveManyToOneRelationInfo(manyToOne)) continue;
            Object child = ReflectUtility.parseFieldValueFromObject(t, manyToOne.name());
            if(child == null) continue;
            processRelationalInsertOrUpdate(child, nodes, connection);
        }
    }



    private void updateChildsWithAutoGeneratedKeys(List<Object> childs, Object autoGeneratedKey, String fieldName) throws Exception{

        if( autoGeneratedKey == null
                || childs.isEmpty()
                ) return;

        for(Object o : childs){
            Class fieldClass = Util.getFieldClass(o.getClass(), fieldName);
            ReflectUtility.mapValue(o, fieldName, fieldClass  , autoGeneratedKey);
        }

    }


    private void updateObjectWithAutoGeneratedKey(Object o, Object autoGeneratedKey) throws Exception{

        if( autoGeneratedKey == null) return;
        PrimaryKeyInfo primaryKeyInfo =  ConfigManager
                                            .getInstance()
                                                .getPrimaryKeyInfo(o.getClass());

        ReflectUtility.mapValue(o
                , primaryKeyInfo.getSinglePrimaryKey()
                , primaryKeyInfo.getClassKeyType(primaryKeyInfo.getSinglePrimaryKey())
                , autoGeneratedKey);
    }

    public void update(Object t) throws Exception{
        update(t,getConnection());
    }

    public void update(Object t, Connection connection) throws Exception{
        execute(ReflectUtility.createSingleRowUpdateSqlString(t));
    }

    public <T> int[] update(List<T> objects)throws Exception{
        return update(objects, getConnection());
    }

    public <T> int[] update(List<T> objects, Connection connection) throws Exception {
        List<String> sqls = new ArrayList<>();
        for(Object o : objects){
            sqls.add(ReflectUtility.createSingleRowUpdateSqlString(o));
        }
        return executeBatch(sqls.toArray(new String[0]), connection);
    }

    public <T> List<T> getAll(Class<T> tClass, String sql) {

        ResultSetUtility resultSetUtility = executeQuery(sql);
        try {
            if(resultSetUtility!=null){
                List<T> result=  resultSetUtility.mapResultsetToObjects(tClass);
                resultSetUtility.close();
                return result;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;

    }
    public <T> List<T> getAll(Class<T> tClass) {
        return getAll(tClass, "select * from " + ConfigManager.getInstance().getTableName(tClass));
    }

    public <T> List<T> getAll(Class<T> tClass, int limit) {
        return getAll(tClass, "select * from " + ConfigManager.getInstance().getTableName(tClass) + " limit " + limit);    }

    public <T> List<T> getAll(Class<T> tClass, int limit, int offset) {
        return getAll(tClass, "select * from " + ConfigManager.getInstance().getTableName(tClass) + " limit " + limit + " offset " + offset);
    }

    public <T> List<T> mapResultSetToObjects(Class<T> tClass, ResultSet resultSet) {
        try {
            return new ResultSetUtility(resultSet).mapResultsetToObjects(tClass);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;

    }

    private List<String> getPrimaryKeys(String table, Connection connection) {


        List<String> primaryKeys = new ArrayList<String>();
        try {
            DatabaseMetaData metaData = connection.getMetaData();
            ResultSet rs = metaData.getPrimaryKeys(ConfigManager.getInstance().getDbName(), null, table);
            while (rs.next()){
                primaryKeys.add(rs.getString("column_name"));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return primaryKeys;

    }


    private  List<String> findPrimaryKeys(Object row, Connection connection) {

        Table tableAnnotation = row.getClass().getAnnotation(Table.class);
        List<String> primaryKeys = new ArrayList<>();
        if(tableAnnotation != null && !tableAnnotation.primaryKeyColumn().isEmpty() ){
            primaryKeys = new ArrayList<>();
            String[] primaryKeysInAnnotation = tableAnnotation.primaryKey().split(",");
            for(String pKey : primaryKeysInAnnotation ){
                primaryKeys.add(pKey.trim());
            }
        }
        if(primaryKeys.isEmpty()){
            primaryKeys = getPrimaryKeys(ConfigManager.getInstance().getTableName(row.getClass()), connection);
        }
        return primaryKeys;

    }




    private void closeResourcesSafely(Connection dbConnection, Statement statement){

        if(statement!=null){
            try {
                statement.close();
            } catch (SQLException e1) {
                e1.printStackTrace();
            }
        }
        if(dbConnection!=null){
            try {
                dbConnection.close();
            } catch (SQLException e1) {
                e1.printStackTrace();
            }
        }
    }




}
